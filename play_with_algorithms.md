## 创建一个泛型数组
T [] datas=(T[])new Object[size];

栈应用的例子
无处不在的撤销（undo）操作
程序调用的系统栈

循环队列关键
* 有两个指针，front 指向队首，tail 指向队尾
* 判断为null front ==tail
* 判断已经满  (tail+1)%c==front   c 是指的队列长度

## 链表
* 最简单的动态数据结构
* 更深入的理解引用（或者指针）
* 更深入的理解递归
* 辅助组成其他复杂数据结构
* 真正的动态，不需要处理动态扩容的问题


## 写递归
1. 求解最基本的问题，也就是问题规模最小的情况写出来，展示出来
2. 把原问题转换成更小的问题，并不是求出更小问题的答案，而是要根据更小问题的答案构建出原问题的答案
递归调用是有代价的： 函数调用+系统栈空间

## 数结构
本身是一种天然的组织结构
将数据使用树结构存储，出奇的高效

二叉树：
* 一种动态数据结构，和链表一样，
* 具有唯一的根节点，
* 最多有两个孩子，左孩子，右孩子，没有孩子的节点成为叶子节点
* 每个节点最多有一个父亲节点
* 具有天然递归结构
    每一个节点的左孩子也是一个二叉树，成为左子数
    每一个节点的右孩子也是一个二叉树，成为右子树
满二叉树：除了叶子节点，其他节点都有两个子节点    ，但是二叉树并不一定是满的
一个节点也可以是一个二叉树
一个NULL也可以是二叉树

二分搜索树
* 是一个二叉树
* 每一个节点的值都大于左子数的所有节点的值，
* 每一个节点的值都小于右子数的所有节点的值
* 每一棵子树也是二分搜索树
* 存储的元素必须有可比较性

BST
### BST 遍历
* 前序遍历  中左右
* 中序遍历  左中右    中序遍历的结果，就是BST所有存储元素排序后的结果
* 后序遍历  左右中  先遍历子节点，在遍历根节点，一个应用场景就是 释放内存的时候
这三种都叫深度优先遍历，顺着一个枝杈，往深度走

前序遍历的非递归写法，
使用栈用来记录接下来要 访问的节点

广度优先遍历，也成为层序遍历，逐层向下，在广度上进行拓展，通常使用非递归，使用队列
可以更快的找到你想查询的那个元素
主要用来搜索策略上
常用与算法设计--最短路径

### BST的最大值和最小值
最小值：从根节点一直向左遍历，再也走不动了，得到的就是最小值
最大值：从根节点一直向右遍历，再也走不动了，得到的就是最大值

删除左右都有孩子的节点d
1. 找到该节点的后继结点s，也就是第一个比该节点大的值，右节点数中最小的那个  s=getMind(d.right)
2. 找到后继结点，然后删除掉这个后继结点
3. 让剩余的右节点树成为后继结点的右节点 s.right=removeMin(d.right)
4. 让删除的节点的做节点树成为后继结点的做节点 s.left=d.Left
5. 删除d节点，后继结点就是这个新的节点

平衡二叉树：AVL，红黑树
堆：并查集
线段树：主要处理线段
Trie(字典树，前缀树)：主要处理字符串

## 集合 set
不重复的数据
有序集合：元素具有顺序， 基于搜索树实现
无序集合： 元素没有顺序，基于Hash表实现
多重集合： 集合中可以重复，可以基于重复的二叉树实现多重集合

## 映射 Map
或者成为字典，单次--->释意
一个内容和另外一个内容搭配来存储数据 key
  身份证--> 人
  车牌号--> 车
  单次统计  单次--->词频
存储键值对（key ,value）的数据结构
根据键，寻找值
使用二分搜索树或者链表可以实现

有序映射： 元素具有顺序， 基于搜索树实现
无序映射： 元素没有顺序，基于Hash表实现
多重映射： 键中可以重复，

当只考虑键的时候，那么映射就可以看成是一个集合
如果集合set 想构建映射Map，那么集合中的E就需要重新分装成包括K和V

## 优先队列
普通队列： 先进先出，后进后出
优先队列：出队顺序和入队顺序无关，和优先级有关，可以使用堆这种数据结构实现

### java 内部实现的优先队列PriorityQueue
1. 内部是一个最小堆
2. 可以接受一个Comparator接口，用来自定义比较器

二叉堆：
* 一个完全二叉树 ，不一定是一个满二叉树，但是缺失那一部分一定得在树的右侧
把元素顺序排列成树的形状
某个节点的值总是不大于其父节点的值，这种叫最大堆
可以使用数组的方式实现二叉堆

## 使用数组表示二叉堆，怎么得到第一个非叶子节点的索引
    第一个非叶子节点的索引就是最后一个叶子节点的父节点，而最后一个叶子节点的索引 index =数组的长度减去1，那么最后一个非叶子节点的索引就是 （index-1）/2  ,第一个节点的索引是0的情况，如果第一个节点的索引是1，那么就是index/2

## 在N个元素中选出M个元素
例如在10000000中取出来前100名
可以使用排序，把这么多数据排序，然后在取出来前100个，时间复杂度是O(nlogn)
还可以使用优先队列，把优先级最高的那几个数据存入到队列中，然后再取出来即可
优先队列，维护当前看到的M个元素，如果再进来的元素比当前队列中最小的那个还大，那么把最小的元素删除，插入这个元素，
这样我们就需要一个最小堆，从堆里取出来最小值，可是我们定义了一个最大堆，
方法一： 再定义一个最小堆，只需要把最大堆中核心代码中的大于改成小于即可
方法二： 因为元素需要实现Comparable即可，可以自己定义优先级，可以把值小的优先级高即可

## 线段树（区间数）
Segment Tree
关系一个线段，或者一个区间

不是完全二叉树，而是平衡二叉树，
平衡二叉树：最大深度和最小深度直接最多相差一
完全二叉树一定是平衡二叉树

## Trie 字典树 前缀树
多叉树，通常只用于字符串
每一个节点有若干个指向下个节点的指针
## UnionFind  并查集
由子节点指向父节点
处理连接问题和路径问题
非常快的判断网络（广义的网络，包括社交网络，计算机中的网络，信息网络，）连接状态
数学中集合的实现，

对于同一组数据，主要支持两个操作
union(q,p) 并，给两个数据，把他们合并起来，
isConnected(p,q) 是否连接

时间复杂度是O(log*n)，比O(logn) 小，近乎是O(1)

## AVL树
二分搜索树的一个问题就是有可能会退化成链表，这样就降低了二分搜索树的效率
AVL是这种树的发明人名字的缩写（G.M.Adelson-Vlesky 和E.M.Landis）
最早的可以自平衡的二分搜索树结构

* 满二叉树：除了叶子节点，其他节点都有两个子节点
* 完全二叉树 : 不一定是一个满二叉树，但是缺失那一部分一定得在树的右侧
* 平衡二叉树：对于任意一个节点来说，左子树的高度和右子树的高度不能超过1

满二叉树肯定是完全二叉树
完全二叉树肯定是平衡二叉树

平和二叉树的高度和节点数量直接的关系也是O(logn)


## 红黑树

### 2-3树
不仅对于零件红黑树有帮助，对于理解B类树，也是有巨大帮助的
满足二分搜索树的基本性质
节点可以存放一个元素或者两个元素
每个节点或者有两个孩子，或者有三个孩子

有三个孩子的，这个节点存放了两个元素，那么这三个孩子，中间的节点在两个元素中间位置

是一个绝对平衡的二叉树，从节点到任意叶子节点的所经过的节点都一样

## 红黑树
是保持黑平衡的二叉树，
严格意义上，不是平衡二叉树，最大高度是2logn，因为每经过一个黑节点，就可能经过一个红节点，但是因为2是常数，所以最大高度还是logn


完全随机的数据，普通的二分搜索树就可以用
极端的情况下，可能退化成链表，或者高度不平衡

对于查询较多的情况下，AVL树很好用

红黑树牺牲了平衡性，但是统计性能更优（综合增删改查操作更优），尤其是经常使用添加和删除操作，












#


















====
