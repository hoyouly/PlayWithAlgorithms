## 创建一个泛型数组
T [] datas=(T[])new Object[size];


栈应用的例子
无处不在的撤销（undo）操作
程序调用的系统栈


循环队列关键
* 有两个指针，front 指向队首，tail 指向队尾
* 判断为null front ==tail
* 判断已经满  (tail+1)%c==front   c 是指的队列长度

```
## 链表
* 最简单的动态数据结构
* 更深入的理解引用（或者指针）
* 更深入的理解递归
* 辅助组成其他复杂数据结构
* 真正的动态，不需要处理动态扩容的问题


## 写递归
1. 求解最基本的问题，也就是问题规模最小的情况写出来，展示出来
2. 把原问题转换成更小的问题，并不是求出更小问题的答案，而是要根据更小问题的答案构建出原问题的答案
递归调用是有代价的： 函数调用+系统栈空间

## 数结构
本身是一种天然的组织结构
将数据使用树结构存储，出奇的高效

二叉树：
* 一种动态数据结构，和链表一样，
* 具有唯一的根节点，
* 最多有两个孩子，左孩子，右孩子，没有孩子的节点成为叶子节点
* 每个节点最多有一个父亲节点
* 具有天然递归结构
    每一个节点的左孩子也是一个二叉树，成为左子数
    每一个节点的右孩子也是一个二叉树，成为右子树
满二叉树：除了叶子节点，其他节点都有两个子节点    ，但是二叉树并不一定是满的
一个节点也可以是一个二叉树
一个NULL也可以是二叉树

二分搜索树
* 是一个二叉树
* 每一个节点的值都大于左子数的所有节点的值，
* 每一个节点的值都小于右子数的所有节点的值
* 每一棵子树也是二分搜索树
* 存储的元素必须有可比较性

BST
### BST 遍历
* 前序遍历  中左右
* 中序遍历  左中右    中序遍历的结果，就是BST所有存储元素排序后的结果
* 后序遍历  左右中  先遍历子节点，在遍历根节点，一个应用场景就是 释放内存的时候

前序遍历的非递归写法，
使用栈用来记录接下来要 访问的节点

平衡二叉树：AVL，红黑树
堆：并查集
线段树：主要处理线段
Trie(字典树，前缀树)：主要处理字符串





















====
